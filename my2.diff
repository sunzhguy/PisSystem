diff --git a/Makefile b/Makefile
index 909c3a6..cc7914b 100755
--- a/Makefile
+++ b/Makefile
@@ -40,8 +40,10 @@ CFLAGS += -DHAVE_PIPE2=1
 CFLAGS += -DNN_HAVE_PIPE2=1
 CFLAGS += -DNN_HAVE_CLOCK_MONOTONIC=1
 
+CFLAGS += -DNN_USE_POLL
 CFLAGS += -DNN_HAVE_POLL=1
-CFLAGS += -DNN_USE_EPOLL=1
+
+#CFLAGS += -DNN_USE_EPOLL=1
 CFLAGS += -DNN_HAVE_ACCEPT4=1
 CFLAGS += -DNN_HAVE_SOCKETPAIR=1
 CFLAGS += -DNN_HAVE_SEMAPHORE=1
@@ -147,8 +149,7 @@ SOURCE  += src/nanomsg/protocols/survey/xsurveyor.c
 
 SOURCE  += src/nanomsg/transports/utils/backoff.c
 SOURCE  += src/nanomsg/transports/utils/dns.c
-SOURCE  += src/nanomsg/transports/utils/dns_getaddrinfo.inc
-SOURCE  += src/nanomsg/transports/utils/dns_getaddrinfo_a.inc
+#SOURCE  += src/nanomsg/transports/utils/dns_getaddrinfo.inc
 SOURCE  += src/nanomsg/transports/utils/iface.c
 SOURCE  += src/nanomsg/transports/utils/literal.c
 SOURCE  += src/nanomsg/transports/utils/port.c
@@ -186,21 +187,20 @@ SOURCE  += src/nanomsg/transports/ws/ws_handshake.c
 SOURCE  += src/nanomsg/transports/ws/sha1.c
 
 		################unix##############
-SOURCE  += src/nanomsg/aio/usock_posix.inc
-SOURCE  += src/nanomsg/aio/worker_posix.inc
-SOURCE  += src/nanomsg/utils/thread_posix.inc
+#SOURCE  += src/nanomsg/aio/usock_posix.inc
+#SOURCE  += src/nanomsg/aio/worker_posix.inc
+#SOURCE  += src/nanomsg/utils/thread_posix.inc
 
 		###############NN_HAVE_POLL)
     	#add_definitions (-DNN_USE_POLL)
-SOURCE  += src/nanomsg/aio/poller_poll.inc
-
+#SOURCE  += src/nanomsg/aio/poller_poll.inc
+SOURCE   += src/nanomsg/aio/poller.c
 		##############NN_HAVE_EVENTFD
-SOURCE  += src/nanomsg/utils/efd_eventfd.h
-SOURCE  += src/nanomsg/utils/efd_eventfd.inc
+#SOURCE  += src/nanomsg/utils/efd_eventfd.h
+#SOURCE  += src/nanomsg/utils/efd_eventfd.c
 
-#SOURCE  += src/timer/evtimer.c
 
-#nanomsg
+#evio
 SOURCE  += src/net/evnet.c
 
 #nanomsg
diff --git a/src/evio/evio.h b/src/evio/evio.h
index ba85736..7a3796b 100755
--- a/src/evio/evio.h
+++ b/src/evio/evio.h
@@ -4,7 +4,7 @@
  * @Author: sunzhguy
  * @Date: 2020-07-16 11:42:41
  * @LastEditor: sunzhguy
- * @LastEditTime: 2020-07-22 10:46:40
+ * @LastEditTime: 2020-11-30 16:51:50
  */ 
 
 #ifndef _EVIO_H_
diff --git a/src/main.c b/src/main.c
index a748597..da6a7c5 100755
--- a/src/main.c
+++ b/src/main.c
@@ -4,7 +4,7 @@
  * @Author: sunzhguy
  * @Date: 2020-07-15 11:02:55
  * @LastEditor: sunzhguy
- * @LastEditTime: 2020-11-30 14:31:00
+ * @LastEditTime: 2020-11-30 16:50:51
  */ 
 
 
@@ -112,7 +112,7 @@ int32_t nn_socket_init(struct server *s)
 {
 	struct servloop *sl = &s->sloop;
 	size_t size = sizeof(size_t);
-	/*sl->sfds_udp.n = nn_socket(AF_SP, NN_PAIR);
+	sl->sfds_udp.n = nn_socket(AF_SP, NN_PAIR);
 	if (-1 == sl->sfds_udp.n)
 		goto err;
 	if (-1 == nn_bind(sl->sfds_udp.n, "inproc://udp2serv"))
@@ -120,18 +120,18 @@ int32_t nn_socket_init(struct server *s)
 	
 	if (-1 == nn_getsockopt(sl->sfds_udp.n, NN_SOL_SOCKET, NN_RCVFD, (char *)&sl->sfds_udp.s, &size))
 		goto err1;
-	*/
+	
 	return 0;
 err1:
-	//nn_close(sl->sfds_udp.n);
+	nn_close(sl->sfds_udp.n);
 err:
 	return -1;
 }
 void nn_socket_close(struct server *s)
 {
 	struct servloop *sl = &s->sloop;
-	//close(sl->sfds_udp.s);
-	//nn_close(sl->sfds_udp.n);
+	close(sl->sfds_udp.s);
+	nn_close(sl->sfds_udp.n);
 
 }
 int32_t  main_loop(struct server *s)
@@ -160,7 +160,7 @@ int32_t  main_loop(struct server *s)
 err2:
 	evctl_free(sl->evctl);
 err1:
-	//nn_socket_close(s);
+	nn_socket_close(s);
 	return -1;
 }
 
diff --git a/src/mini-heap/mini-heap.c b/src/mini-heap/mini-heap.c
index 610f2d5..aa9b257 100755
--- a/src/mini-heap/mini-heap.c
+++ b/src/mini-heap/mini-heap.c
@@ -4,7 +4,7 @@
  * @Author: sunzhguy
  * @Date: 2020-07-15 10:06:14
  * @LastEditor: sunzhguy
- * @LastEditTime: 2020-07-16 17:56:56
+ * @LastEditTime: 2020-12-01 10:26:33
  */ 
 #include <stdlib.h>
 #include <string.h>
@@ -16,157 +16,156 @@
 //#define heap_right(npos) (((npos)*2)+2)          /*npos的右兄弟结点*/
 
 
-int  heap_size(void *self)
+int  MiniHeap_Size(void *self)
 {
-    Heap *heap = (Heap*)self;
-    return heap->size;
+    T_HEAP *ptHeap = (T_HEAP*)self;
+    return ptHeap->iSize;
 }
 /*heap_init 堆的初始化*/
-void heap_init(void *self,heap_compare_t compare,heap_destroy_t destroy,heap_index_t index)
+void MiniHeap_Init(void *self,PF_HEAP_COMPARE compare,PF_HEAP_DESTROY destroy,PF_HEAP_INDEX index)
 {
-    Heap *heap = (Heap*)self;
+    T_HEAP *ptHeap = (T_HEAP*)self;
     /*只需要将size设为0，destroy成员指向destroy，将tree指针设置为NULL*/
-    heap->size = 0;
-    heap->compare = compare;
-    heap->destroy = destroy;
-    heap->index = index;
-    heap->tree = NULL;
-
+    ptHeap->iSize = 0;
+    ptHeap->pFCompare = compare;
+    ptHeap->pFDestory = destroy;
+    ptHeap->pFIndex = index;
+    ptHeap->tree = NULL;
     return ;
 }
 /*heap_destroy  销毁堆*/
-void heap_destroy(void *self)
+void MiniHeap_Destroy(void *self)
 {
     int i;
-     Heap *heap = (Heap*)self;
+     T_HEAP *ptHeap = (T_HEAP*)self;
     /*移除堆中所有的结点*/
-    if(heap->destroy != NULL)
+    if(ptHeap->pFDestory != NULL)
     {
-        for(i=0; i<heap_size(heap);i++)
+        for(i=0; i<MiniHeap_Size(ptHeap);i++)
         {
             /*调用用户自定义函数释放动态分配的数据*/
-            heap->destroy(heap->tree[i]);
+            ptHeap->pFDestory(ptHeap->tree[i]);
         }
     }
     /*释放为堆分配的空间*/
-    free(heap->tree);
+    free(ptHeap->tree);
 
-    memset(heap,0,sizeof(Heap));
+    memset(ptHeap,0,sizeof(T_HEAP));
     return;
 }
 
 /*heap_insert  向堆中插入结点*/
-int heap_insert(void *self,const void *data)
+int MiniHeap_Insert(void *self,const void *data)
 {
-    void *temp;
+    void *vdtemp;
     int  ipos;
     int  ppos;
-     Heap *heap = (Heap*)self;
-    int size = (heap_size(heap)+1)*sizeof(void *);
+    T_HEAP *ptHeap = (T_HEAP*)self;
+    int size = (MiniHeap_Size(ptHeap)+1)*sizeof(void *);
     /*为结点分配空间*/
-    if((temp = (void **)realloc(heap->tree,size)) == NULL)
+    if((vdtemp = (void **)realloc(ptHeap->tree,size)) == NULL)
     {
         return -1;
     }
     else
     {
-        heap->tree = temp;
+        ptHeap->tree = vdtemp;
     }
     /*将结点插入到堆的最末端*/
-    heap->tree[heap_size(heap)] = (void *)data;
+    ptHeap->tree[MiniHeap_Size(ptHeap)] = (void *)data;
     /*将新结点向上推动，恢复堆的排序特点*/
-    ipos = heap_size(heap);    /*堆结点数的数值*/
+    ipos = MiniHeap_Size(ptHeap);    /*堆结点数的数值*/
 
-    if (heap->index) {			
+    if (ptHeap->pFIndex) {			
 		/* 设置新节点索引值*/	
-		heap->index(heap->tree[ipos], ipos);
+		ptHeap->pFIndex(ptHeap->tree[ipos], ipos);
 	}
 
-    ppos = heap_parent(ipos);  /*ipos位置结点的父结点*/
+    ppos = HEAP_PARENT(ipos);  /*ipos位置结点的父结点*/
     /*如果堆不为空，且新成员(优先级)小于父节点==>最小堆模式*/
-    while(ipos>0 && heap->compare(heap->tree[ppos],heap->tree[ipos])<0)
+    while(ipos>0 && ptHeap->pFCompare(ptHeap->tree[ppos],ptHeap->tree[ipos])<0)
     {
         /* 临时存放父节点成员 */
-        temp = heap->tree[ppos];
+        vdtemp = ptHeap->tree[ppos];
         /* 新成员存放到父节点位置 */
-        heap->tree[ppos] = heap->tree[ipos];
+        ptHeap->tree[ppos] = ptHeap->tree[ipos];
         /* 父节点成员被放置到之前新成员所在的位置 */
-        heap->tree[ipos] = temp;
+        ptHeap->tree[ipos] = vdtemp;
 
-	    if (heap->index) {			
+	    if (ptHeap->pFIndex) {			
 			/* 修改新节点索引值*/ 	
-			heap->index(heap->tree[ppos], ppos);			
+			ptHeap->pFIndex(ptHeap->tree[ppos], ppos);			
 			/* 修改父节点索引值*/ 	
-			heap->index(heap->tree[ipos], ipos);
+			ptHeap->pFIndex(ptHeap->tree[ipos], ipos);
 		}
         /* 改变新节点成员在指针数组中的下标为之前其父节点的下标值 */
         ipos = ppos;
-        ppos = heap_parent(ipos);
+        ppos = HEAP_PARENT(ipos);
     }
 
     /*堆插入与排序完成，调整堆的结点数量值*/
-    heap->size++;
+    ptHeap->iSize++;
 
     return 0;
 }
 
 /*heap_extract 释放堆顶部的结点*/
-int heap_extract(void *self,void **data)
+int MiniHeap_Extract(void *self,void **data)
 {
-    void *save,*temp;
+    void *vdsave,*vdtemp;
     int  ipos,lpos,rpos,mpos;
-    Heap *heap = (Heap*)self;
+    T_HEAP *ptHeap = (T_HEAP*)self;
     /*不允许从空的堆中释放结点*/
-    if(heap_size(heap) == 0)
+    if(MiniHeap_Size(ptHeap) == 0)
         return -1;
 
     /*释放堆顶部的结点*/
     /*首先将data指向将要释放结点的数据*//* 取堆中首元素 */	
 	if(NULL != data)
-    *data = heap->tree[0];
+    *data = ptHeap->tree[0];
 
     /*将save指向未位结点*/
-    save = heap->tree[heap_size(heap)-1];
+    vdsave = ptHeap->tree[MiniHeap_Size(ptHeap)-1];
 
-    if(heap_size(heap)-1 > 0)
+    if(MiniHeap_Size(ptHeap)-1 > 0)
     {   /*为堆分配一个稍小一点的空间*/
-        if((temp = (void **)realloc(heap->tree,(heap_size(heap)-1)*sizeof(void *)))==NULL)
+        if((vdtemp = (void **)realloc(ptHeap->tree,(MiniHeap_Size(ptHeap)-1)*sizeof(void *)))==NULL)
         {
             return -1;
         }
         else
         {
-            heap->tree = temp;
+            ptHeap->tree = vdtemp;
         }
         /*调整堆的大小*/
-        heap->size--;
+        ptHeap->iSize--;
     }
     else
     {   /*只有一个结点，释放并重新管理堆，并返回*/
-        free(heap->tree);
-        heap->tree = NULL;
-        heap->size = 0;
+        free(ptHeap->tree);
+        ptHeap->tree = NULL;
+        ptHeap->iSize = 0;
         return 0;
     }
     /*将末位结点拷贝到根结点中*/
-    heap->tree[0] = save;
+    ptHeap->tree[0] = vdsave;
 
     /*重新调整树的结构*/
     ipos = 0;                /*顶元素*/
-    if (heap->index) {			
-		heap->index(heap->tree[0], ipos);			
+    if (ptHeap->pFIndex) {			
+		ptHeap->pFIndex(ptHeap->tree[0], ipos);			
 	}
-    lpos = heap_left(ipos);  /*左子结点*/
-    rpos = heap_right(ipos); /*右子结点*/
+    lpos = HEAP_LEFT(ipos);  /*左子结点*/
+    rpos = HEAP_RIGHT(ipos); /*右子结点*/
 
     /*父结点与两个子结点比较、交换，直到不再需要交换为止，或者结点到达一个叶子位置*/
     while(1)
     {
         /*选择子结点与当前结点进行交换*/
-        lpos = heap_left(ipos);
-        rpos = heap_right(ipos);
+        lpos = HEAP_LEFT(ipos);
+        rpos = HEAP_RIGHT(ipos);
         /*父结点与左子结点位置不正确,左子结点大于其父结点*/
-        if(lpos < heap_size(heap) && heap->compare(heap->tree[ipos],heap->tree[lpos])<0)
+        if(lpos < MiniHeap_Size(ptHeap) && ptHeap->pFCompare(ptHeap->tree[ipos],ptHeap->tree[lpos])<0)
         {
             mpos = lpos;  /* 最小堆模式时，mpos值为当前父节点和左孩子中的优先级高(即值较小者)的下标 */
         }
@@ -175,7 +174,7 @@ int heap_extract(void *self,void **data)
             mpos = ipos;
         }
 
-        if(rpos < heap_size(heap) && heap->compare(heap->tree[mpos],heap->tree[rpos])<0)
+        if(rpos < MiniHeap_Size(ptHeap) && ptHeap->pFCompare(ptHeap->tree[mpos],ptHeap->tree[rpos])<0)
         {
             /* 之前优先级高的节点和右孩子进行比较 */
             mpos = rpos;
@@ -190,13 +189,13 @@ int heap_extract(void *self,void **data)
         else
         {
             /*交换当前结点与被选中的结点的内容*/
-            temp = heap->tree[mpos];
-            heap->tree[mpos] = heap->tree[ipos];
-            heap->tree[ipos] = temp;
+            vdtemp = ptHeap->tree[mpos];
+            ptHeap->tree[mpos] = ptHeap->tree[ipos];
+            ptHeap->tree[ipos] = vdtemp;
 
-	        if (heap->index) {			
-				heap->index(heap->tree[mpos], mpos);			
-				heap->index(heap->tree[ipos], ipos);
+	        if (ptHeap->pFIndex) {			
+				ptHeap->pFIndex(ptHeap->tree[mpos], mpos);			
+				ptHeap->pFIndex(ptHeap->tree[ipos], ipos);
 			}
             /*下移一层，以继续执行堆排序*/
             ipos = mpos;
diff --git a/src/mini-heap/mini-heap.h b/src/mini-heap/mini-heap.h
index d83c968..dd8c9ef 100755
--- a/src/mini-heap/mini-heap.h
+++ b/src/mini-heap/mini-heap.h
@@ -4,7 +4,7 @@
  * @Author: sunzhguy
  * @Date: 2020-07-15 09:58:54
  * @LastEditor: sunzhguy
- * @LastEditTime: 2020-07-16 17:56:48
+ * @LastEditTime: 2020-12-01 10:00:26
  */ 
 #ifndef MINI_HEAP_H
 #define MINI_HEAP_H
@@ -13,27 +13,27 @@
 #include <unistd.h>
 
 //#define heap_size(heap) 	((heap)->size)
-#define heap_parent(npos)	((int32_t)(((npos) - 1) / 2))
-#define heap_left(npos)		(((npos) * 2) + 1)
-#define heap_right(npos)	(((npos) * 2) + 2)
+#define HEAP_PARENT(npos)	((int32_t)(((npos) - 1) / 2))
+#define HEAP_LEFT(npos)		(((npos) * 2) + 1)
+#define HEAP_RIGHT(npos)	(((npos) * 2) + 2)
 
-typedef int32_t (*heap_compare_t)(const void *, const void *);
-typedef void (*heap_destroy_t)(void *);
-typedef void (*heap_index_t)(void *, const uint32_t);
+typedef int32_t (*PF_HEAP_COMPARE)(const void *, const void *);
+typedef void (*PF_HEAP_DESTROY)(void *);
+typedef void (*PF_HEAP_INDEX)(void *, const uint32_t);
 
 typedef struct {
-	int32_t	size;
-	heap_compare_t compare;
-	heap_destroy_t destroy;
-	heap_index_t index;
+	int32_t	iSize;
+	PF_HEAP_COMPARE pFCompare;
+	PF_HEAP_DESTROY pFDestory;
+	PF_HEAP_INDEX   pFIndex;
 	void **tree;
-}Heap;
+}T_HEAP;
 
-void heap_init(void *, heap_compare_t, heap_destroy_t,heap_index_t);
-void heap_destroy(void *);
-int32_t heap_insert(void *, const void *);
-int32_t heap_extract(void *, void **);
-int32_t heap_size(void *);
+void MiniHeap_Init(void *, PF_HEAP_COMPARE, PF_HEAP_DESTROY,PF_HEAP_INDEX);
+void MiniHeap_Destroy(void *);
+int32_t MiniHeap_Insert(void *, const void *);
+int32_t MiniHeap_Extract(void *, void **);
+int32_t MiniHeap_Size(void *);
 
 
 
diff --git a/src/timer/evtimer.c b/src/timer/evtimer.c
index 31194d2..4657be6 100755
--- a/src/timer/evtimer.c
+++ b/src/timer/evtimer.c
@@ -4,7 +4,7 @@
  * @Author: sunzhguy
  * @Date: 2020-07-16 08:45:42
  * @LastEditor: sunzhguy
- * @LastEditTime: 2020-07-17 16:17:49
+ * @LastEditTime: 2020-12-01 11:19:03
  */ 
 
 #include <stdio.h>
@@ -12,78 +12,78 @@
 #include "evtimer.h"
 
 /*最小堆 定时器值比较*/
-int32_t ev_timer_compare(const void *v1, const void *v2)
+static int32_t _EV_TIMER_Compare(const void *_v1, const void *_v2)
 {
-    const ev_timer_t *t1 = v1;
-	const ev_timer_t *t2 = v2;
+    const T_EV_TIMER *pt1 = _v1;
+	const T_EV_TIMER *pt2 = _v2;
 
-	if(t1->expire > t2->expire)
+	if(pt1->u64Expire > pt2->u64Expire)
 		return -1;
 	else
 		return 0;
 }
 
 /*返回最小堆根节点得值*/
-ev_timer_t *ev_timer_ctl_peek(void *_self)
+static T_EV_TIMER *_EV_TIMER_Peek(void *_self)
 {
-	timer_miniHeap *self = _self;
-	return (ev_timer_t *)(self->tree == NULL ? NULL : self->tree[0]);
+	T_HEAP *ptHeap = (T_HEAP *)_self;
+	return (T_EV_TIMER *)(ptHeap->tree == NULL ? NULL : ptHeap->tree[0]);
 }
 /*定时器最小堆索引记录，对删除定时器得值起到作用*/
-void ev_timer_index(void *_self, const uint32_t _index)
+static void _EV_TIMER_Index(void *_self, const uint32_t _index)
 {
-	ev_timer_t *self = _self;
+	T_EV_TIMER *ptEvTimer = (T_EV_TIMER *)_self;
 	 //printf("<expire-%d index-%d-->%d\r\n",self->expire,self->index,_index);
-	self->index = _index;
+	ptEvTimer->u64Index= _index;
 }
 
 /* 删除某个具体的timer ，这个timer要自己释放*/
-int32_t ev_timer_ctl_remove(void *_self, ev_timer_t *timer)
+static int32_t _EV_TIMER_Remove(void *_self, T_EV_TIMER *_pTimer)
 {
-	timer_miniHeap *self = _self;
-	void *temp;
+	T_HEAP *ptHeap = (T_HEAP *)_self;
+	void *vdtemp;
 	int32_t ipos, lpos, rpos, mpos;
 
-	if (0 == self->size) {
+	if (0 == ptHeap->iSize) {
 		return -1;
 	}
 	/* 最后一个成员顶替要被删除成员的位置*/
-	printf("delete timer_index:%d\r\n",timer->index);
-	self->tree[timer->index] = self->tree[self->size - 1];
+	printf("delete timer_index:%d\r\n",_pTimer->u64Index);
+	ptHeap->tree[_pTimer->u64Index] = ptHeap->tree[ptHeap->iSize - 1];
 	/* 然后改变其索引值*/
-	self->index(self->tree[timer->index], timer->index);
+	ptHeap->pFIndex(ptHeap->tree[_pTimer->u64Index], _pTimer->u64Index);
 
-	if (self->size - 1 > 0) {
-		if ((temp = (void **)realloc(self->tree, (self->size - 1) * sizeof(void *))) == NULL) {
+	if (ptHeap->iSize - 1 > 0) {
+		if ((vdtemp = (void **)realloc(ptHeap->tree, (ptHeap->iSize - 1) * sizeof(void *))) == NULL) {
 	      	return -1;
 	   	}
 	   	else {
-	    	self->tree = temp;
+	    	ptHeap->tree = vdtemp;
 	   	}
 
-	   	self->size--;
+	   	ptHeap->iSize--;
 	}
 	else {
-	   	free(self->tree);
-	   	self->tree = NULL;
-	   	self->size = 0;
+	   	free(ptHeap->tree);
+	   	ptHeap->tree = NULL;
+	   	ptHeap->iSize = 0;
 	   	return 0;
 	}
 
-	ipos = timer->index;
+	ipos = _pTimer->u64Index;
 
 	while (1) {
-		lpos = heap_left(ipos);
-		rpos = heap_right(ipos);
+		lpos = HEAP_LEFT(ipos);
+		rpos = HEAP_RIGHT(ipos);
 
-		if (lpos < heap_size(self) && self->compare(self->tree[ipos], self->tree[lpos]) < 0) {
+		if (lpos < MiniHeap_Size(ptHeap) && ptHeap->pFCompare(ptHeap->tree[ipos], ptHeap->tree[lpos]) < 0) {
 			mpos = lpos;
 		}
 		else {
 			mpos = ipos;
 		}
 
-		if (rpos < heap_size(self) && self->compare(self->tree[mpos], self->tree[rpos]) < 0) {
+		if (rpos < MiniHeap_Size(ptHeap) && ptHeap->pFCompare(ptHeap->tree[mpos], ptHeap->tree[rpos]) < 0) {
 			mpos = rpos;
 		}
 
@@ -91,13 +91,13 @@ int32_t ev_timer_ctl_remove(void *_self, ev_timer_t *timer)
 			break;
 		}
 		else {
-			temp = self->tree[mpos];
-			self->tree[mpos] = self->tree[ipos];
-			self->tree[ipos] = temp;
+			vdtemp = ptHeap->tree[mpos];
+			ptHeap->tree[mpos] = ptHeap->tree[ipos];
+			ptHeap->tree[ipos] = vdtemp;
 			
-			if (self->index) {			
-				self->index(self->tree[mpos], mpos);			
-				self->index(self->tree[ipos], ipos);
+			if (ptHeap->pFIndex) {			
+				ptHeap->pFIndex(ptHeap->tree[mpos], mpos);			
+				ptHeap->pFIndex(ptHeap->tree[ipos], ipos);
 			}
 			
 			ipos = mpos;
@@ -109,25 +109,22 @@ int32_t ev_timer_ctl_remove(void *_self, ev_timer_t *timer)
 
 
 /*创建定时器控制*/
-ev_timer_ctl_t *ev_timer_ctl_create(void)
+T_EV_TIMER_CTRL *EV_TIMER_CTRL_Creator(void)
 {
-
-	ev_timer_ctl_t *ctl = calloc(1, sizeof(ev_timer_ctl_t));
-	if(NULL == ctl)
-		goto err;
-
-	ctl->dtor = heap_destroy;
-	ctl->push = heap_insert;
-	ctl->pop = heap_extract;
-	ctl->size = heap_size;
-	ctl->peek = ev_timer_ctl_peek;
+	T_EV_TIMER_CTRL *ptEvTimerCtrl = calloc(1, sizeof(T_EV_TIMER_CTRL));
+	if(NULL == ptEvTimerCtrl)
+		return NULL;
+
+	ptEvTimerCtrl->pFEvTimerCtlDtor = MiniHeap_Destroy;
+	ptEvTimerCtrl->pFEvTimerCtlPush = MiniHeap_Insert;
+	ptEvTimerCtrl->pFEvTimerCtlPop  = MiniHeap_Extract;
+	ptEvTimerCtrl->pFEvTimerCtlSize = MiniHeap_Size;
+	ptEvTimerCtrl->pFEvTimerCtlPeek = _EV_TIMER_Peek;
 	//ctl->match = ev_timer_match;
-	ctl->remove = ev_timer_ctl_remove;
-	heap_init(ctl, ev_timer_compare,NULL, ev_timer_index);	
-	return ctl;
-	
-err:
-	return NULL;
+	ptEvTimerCtrl->pFEvTimerCtlRemove = _EV_TIMER_Remove;
+	MiniHeap_Init(ptEvTimerCtrl, _EV_TIMER_Compare,NULL, _EV_TIMER_Index);	
+	return ptEvTimerCtrl;
+
 
 }
 
diff --git a/src/timer/evtimer.h b/src/timer/evtimer.h
index c09a0d7..86aa8a6 100755
--- a/src/timer/evtimer.h
+++ b/src/timer/evtimer.h
@@ -4,7 +4,7 @@
  * @Author: sunzhguy
  * @Date: 2020-07-16 08:45:29
  * @LastEditor: sunzhguy
- * @LastEditTime: 2020-07-21 15:53:17
+ * @LastEditTime: 2020-12-01 11:20:19
  */ 
 
 #ifndef _MINI_TIMER_H_
@@ -12,35 +12,35 @@
 #include <stdint.h>
 #include "../mini-heap/mini-heap.h"
 
-typedef struct _ev_timer_t ev_timer_t;
-typedef Heap  timer_miniHeap;
-typedef void (*ev_timer_cb_t)(void *, ev_timer_t *, void *);
+typedef struct _EV_TIMER_T T_EV_TIMER;
 
-struct _ev_timer_t {
-	uint64_t index;
-	uint64_t expire;
-	ev_timer_cb_t cb;
-	void *arg;
+typedef void (*PF_EVTIMER_CB)(void *, T_EV_TIMER *, void *);
+
+struct _EV_TIMER_T {
+	uint64_t u64Index;
+	uint64_t u64Expire;
+	PF_EVTIMER_CB pFEvTimerCb;
+	void *vpArg;
 };
-typedef void (*ev_timer_ctl_dtor_t)(void *);
-typedef int32_t (*ev_timer_ctl_push_t)(void *, const void *);
-typedef int32_t (*ev_timer_ctl_pop_t)(void *, void **);
-typedef int32_t (*ev_timer_ctl_remove_t)(void *, ev_timer_t *);
-typedef ev_timer_t *(*ev_timer_ctl_peek_t)(void *);
-typedef int32_t (*ev_timer_ctl_size_t)(void *);
-typedef ev_timer_t *(*ev_timer_ctl_match_t)(void *, void *);
+typedef void 		(*PF_EVTIMER_CTL_MINIHP_DESTRY)(void *);
+typedef int32_t 	(*PF_EVTIMER_CTL_MINIHP_PUSH)(void *, const void *);
+typedef int32_t 	(*PF_EVTIMER_CTL_MINIHP_POP)(void *, void **);
+typedef int32_t 	(*PF_EVTIMER_CTL_MINIHP_REMOVE)(void *, ev_timer_t *);
+typedef T_EV_TIMER *(*PF_EVTIMER_CTL_MINIHP_PEEK)(void *);
+typedef int32_t 	(*PF_EVTIMER_CTL_MINIHP_SIZE)(void *);
+typedef T_EV_TIMER *(*PF_EVTIMER_CTL_MINIHP_MATCH)(void *, void *);
 
-typedef struct ev_timer_ctl_t {
-	timer_miniHeap    timer_list;    //此变量传递强制转换作为最小堆存储管理来使用
-	ev_timer_ctl_dtor_t dtor;
-	ev_timer_ctl_push_t push;
-	ev_timer_ctl_pop_t pop;
-	ev_timer_ctl_remove_t remove;
-	ev_timer_ctl_peek_t peek;
-	ev_timer_ctl_size_t size;
+typedef struct _T_EV_TIMER_CTRL {
+	T_HEAP    tHeapTimer;    //此变量传递强制转换作为最小堆存储管理来使用
+	PF_EVTIMER_CTL_MINIHP_DESTRY pFEvTimerCtlDtor;
+	PF_EVTIMER_CTL_MINIHP_PUSH 	 pFEvTimerCtlPush;
+	PF_EVTIMER_CTL_MINIHP_POP    pFEvTimerCtlPop;
+	PF_EVTIMER_CTL_MINIHP_REMOVE pFEvTimerCtlRemove;
+	PF_EVTIMER_CTL_MINIHP_PEEK 	 pFEvTimerCtlPeek;
+	PF_EVTIMER_CTL_MINIHP_SIZE 	 pFEvTimerCtlSize;
 	//ev_timer_ctl_match_t match;
-}ev_timer_ctl_t;
+}T_EV_TIMER_CTRL;
 
 
-ev_timer_ctl_t *ev_timer_ctl_create(void);
+T_EV_TIMER_CTRL *EV_TIMER_Ctl_Creator(void);
 #endif
\ No newline at end of file
diff --git a/src/udp_service.c b/src/udp_service.c
index 30cdf80..509ac73 100755
--- a/src/udp_service.c
+++ b/src/udp_service.c
@@ -4,7 +4,7 @@
  * @Author: sunzhguy
  * @Date: 2020-07-22 08:40:25
  * @LastEditor: sunzhguy
- * @LastEditTime: 2020-11-30 11:22:56
+ * @LastEditTime: 2020-11-30 16:55:07
  */ 
 #include <unistd.h>
 #include <stdio.h>
@@ -12,7 +12,10 @@
 #include "net/evnet.h"
 #include "udp_service.h"
 #include "evio/evio.h"
+#include "nanomsg/pair.h"
+#include "nanomsg/nn.h"
 #include "main.h"
+#include <assert.h>
 
 struct netfds {
 	int s;			/* sys fd*/
@@ -91,7 +94,7 @@ static void server_to_udp_cb(ev_ctl_t *evctl, ev_fd_t *evfd, int fd, ev_type_t t
 
 void udp_ctrl_init(struct udp_net_ctl *ctl)
 {
-	#if 0
+	struct servloop * sl =&ctl->arg->sloop;
     ctl->s2udp.n = nn_socket(AF_SP, NN_PAIR);
 	if (-1 == ctl->s2udp.n)
 		goto err1;
@@ -100,28 +103,25 @@ void udp_ctrl_init(struct udp_net_ctl *ctl)
 	size_t size = sizeof(size_t);
 	if (-1 == nn_getsockopt(ctl->s2udp.n, NN_SOL_SOCKET, NN_RCVFD, (char *)&ctl->s2udp.s, &size))
 		goto err2;
-	#endif
+
 	ctl->evctl = evctl_create();
 	if (NULL == ctl->evctl)
 		goto err3;
 	
-	#if 0
     ctl->s2udp.cb = handle_data_udp_form_server;
     ctl->s2udp.arg = ctl;
     ctl->s2udp.evfd = ev_fd_add(ctl->evctl, sl->sfds_udp.s, server_to_udp_cb, &sl->sfds_udp);//add the event fd 
-	if (NULL == ctl->ss.evfd)
+	if (NULL == ctl->s2udp.evfd)
 		goto err4;
-	
-    ctl->evctl->watch_read(ctl->evctl, ctl->ss.evfd);
-	#endif
+	ev_watch_read(ctl->evctl, sl->sfds_udp.evfd);
   err5:
-	//ctl->evctl->del(ctl->evctl, ctl->ss.evfd);
+	ev_fd_del(ctl->evctl, ctl->s2udp.evfd);
 err4:
 	evctl_free(ctl->evctl);
 err3:
-	//close(ctl->s2udp.s);
+	close(ctl->s2udp.s);
 err2:
-	//nn_close(ctl->s2udp.n);
+	nn_close(ctl->s2udp.n);
 err1:
 	return -1;
 }
@@ -133,8 +133,7 @@ void *udp_service(void *arg)
      ev_ctl_t * ev_ctrl = evctl_create();
      if(ev_ctrl == NULL)
       goto err;
-    //assert(0 == pthread_create(&thread_ubroadt, NULL,udp_broadcast_service,s));
-	pthread_create(&thread_ubroadt, NULL,udp_broadcast_service,s);
+    assert(0 == pthread_create(&thread_ubroadt, NULL,udp_broadcast_service,s));
 
     pthread_mutex_lock(&s->start_lock);
 	++s->start_num;
